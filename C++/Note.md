+ 形参 formal parameter
+ 实参 actual parameter

#### 传值参数(value parameter) 
在函数执行前，把实参复制给形参。复制过程是由形参类型的复制构造函数(copy constructor)完成的。在函数结束后，形参类型的析构函数(destructor)负责释放形式参数。

#### 引用参数(reference parameter) 
各个实参是各个形参的别名，在函数执行前，程序没有复制实参的值，在函数结束后，也没有调用析构函数。

模板函数的参数类型是一个变量，它的值由编译器决定

#### 引用返回(reference return) 
函数返回类型增加一个后缀&，返回的是一个引用。引用只是一个别名，不是一种数据类型，也不占存储单元。

 const 用于常量引用与const型引用返回

#### 签名(signature) 
由该函数的形参类型以及形参个数确定。任何两个同名函数不能有同样的签名。

#### 函数重载(fuction overloading) 
定义多个同名函数的机制

关于C++函数结束之前一定要delete之前new的数组以及函数里面定义变量的问题？

必须要 delete，只有指向这两个数组的两个指针才是局部变量。如果没有在函数内部 delete，函数结束后指向这两个数组的指针就会被销毁，无法释放这两个数组占用的内存。2. 在函数内定义的静态变量会在程序运行期间一直占用内存，不管函数有没有被调用。

异常
+ 抛出异常 throw
+ 处理异常 catch(类型 变量)
          catch(...){}  捕获所有类型的异常

动态生成二维、多维数组 需要依次生成之前的数组
```
x = new int* [numOfRows]
for(int i=0;i<numOfRows;i++){
    x[i] = new int [numOfColumns];
}
```
delete []x 释放数组x的空间
```
for(int i=0;i<numOfRows;i++){
    delete [] x[i];
}
delete []x;
x = NULL;
```
比类名多了一个前缀~的函数：析构函数
析构函数通常为{} 如果创建了动态数组，那么当对象超过作用域时，析构函数需要释放动态数组空间，这时的析构函数就不是空函数。

成员函数如果不在类声明体里实现吗，而在外部实现，就必使用作用域说明符(scope resolution operator):: 以指明该函数是其类的成员函数

## 第5章
C++支持两种类：抽象类和具体类

+ 一个抽象类包含着没有实现代码的成员函数，称为纯虚函数(pure virtual function)

  纯虚函数用数字0作为初始值来说明， 如：
virtual int myPureVirtualFuction(int x) = 0;
+ 具体类是没有纯虚函数的类，只有具体类才可以实例化

C++迭代器（interator)

## 第6章
### 数组描述与链表描述的线性表 性能比较
+内存比较
 
    设有n个元素,一个元素需要s个字节,一个指针需要4个字节
    数组描述需要空间：ns~4ns
    链表描述所需空间：n(s+4)

+时间比较

    get/indexOf: 数组<<链表
    插入：
        最好情况：数组<链表 （也可认为约等于）
        最坏情况: 数组<<链表
        平均情况：数组<<链表
        其中，链表的 最坏情况<<平均情况
        因为平均情况的随机访问导致很多高速缓存的流失
    删除(书上给的，未验证):
        最好情况：数组约等于链表
        最坏情况：数组<<链表
        平均情况：数组<<链表

### 箱子排序 bin sort
1) 逐个删除输入链表的节点，把删除的节点分配到相应的箱子里
2) 把每一个箱子中的链表收集并且链接起来，使其成为一个有序链表

可以令每个箱子都有两个指针，分别存储在数组bottom和top中，分别指向尾结点和头结点。

时间复杂度：
    
    创建并初始化bottom/top: O(range)
    把链表的节点分配到箱子里: O(n)
    把箱子里的节点收集到有序链表: O(range)
    总的时间复杂度: O(n+range)

### 基数排序 radix sort
思想: 因为箱子排序是稳定排序，所以可以多次按照节点中不同的属性进行箱子排序，上一次箱子排序的次序保持不变

假设对0~10^6-1的1000个整数进行排序，使用基数r=10^6的排序方法相当于直接对数使用箱子排序，对箱子初始化需要10^6个执行步，节点分配需要1000个执行步，收集箱子需要10^6个执行步，总步数为2001000。
若使用基数r=1000的排序方法，则过程如下：
1) 采用每个数的最低三位数字进行排序，令range=1000
2) 对1)的结果按倒数次三位进行排序

总共只需要6000个执行步骤
而对基数r=100 需要3600个执行步，对基数r=10，需要6120个执行步

如果以基数r来分解，那么相应的分解式为
x%r/1, (x%r^2)/r, (x%r^3)/r^2 。。。。

当使用r=n对0~n^c-1范围内的n个整数进行分解时，每个数可以分解出c个数字, 可以用c次range=n个箱子排序，时间复杂度为O(cn) = O(n)

### 凸包 convex hull
一个平面点集S的凸包是指包含S的最小凸多边形

该多边形的顶点成为S的极点(extreme point)

在S的凸包内部取一个点X，然后从X向下画一条垂直线，这条垂直线与X和S的第i个点的连线之间有一个逆时针夹角，称为极角(polar)

当按照极角次序排列的三个连续点之间的逆时针夹角小于或等于180度时，第二个点不是极点

寻找S的凸包：

1) 处理退化情况\
   如果S的点少于3个，则返回S\
   如果S的所有点在一条直线上，则返回两个端点
2) 按极角排序\
   在S的凸包内找到一个点X （可利用三角形的中心，视其为X）\
   按照极角递增次序来排列S的点，对于极角相同的点，按照它们与X的距离从小到大进行排列\
   创建一个以S的点为元素（可取y坐标最小的点，因为必然在凸包中），按照上述顺序排列的双向循环链表
3) 删除非极点的点\
   令p是y坐标最小的点
   ```
   for(x=p, rx=x->right;p!=rx;){
       rrx = rx->right;
       if(x, rx, rrx的逆时针夹角小于或等于180度){
           从链表中删除rx;
           x = rrx;
           rx = x->right;
       } 
       else{
           x = rx;
           rx = rrx;
       }
   }
   ```
### 并查集 union-find
等价关系R：自反/对称/传递\
等价类(equiralence class)是指相互等价的元素的最大集合\
一个元素只能属于一个等价类
离线等价类(offiline equiralence class)问题:\
已知n和R,确定所有的等价类\
在线等价类(online equiralence class)问题:\
初始时有n个元素，每个元素都属于一个独立的等价类。需要执行1)combine(a, b),把包含a和b的等价类合并成一个等价类;2)find(theElement),确定元素theElement在哪一个类\
在线等价类问题通常又被称为并查集(union-find)问题


## 第11章
建立二叉树的时候又忘了形参与实参。。

### typedef 与 typename 的用法
### 函数指针的声明/定义 

